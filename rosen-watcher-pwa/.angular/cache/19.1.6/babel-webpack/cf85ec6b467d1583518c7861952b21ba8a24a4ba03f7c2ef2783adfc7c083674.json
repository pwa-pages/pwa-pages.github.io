{"ast":null,"code":"import Chart from 'chart.js/auto';\nimport 'chartjs-adapter-date-fns';\nimport * as i0 from \"@angular/core\";\nexport let ChartService = /*#__PURE__*/(() => {\n  class ChartService {\n    constructor() {\n      this.chartColors = ['#1f77b4',\n      // Blue\n      '#2ca02c',\n      // Green\n      '#bcbd22',\n      // Yellow-Green\n      '#d62728',\n      // Red\n      '#ff7f0e',\n      // Orange\n      '#8c564b',\n      // Brown\n      '#e377c2',\n      // Pink\n      '#7f7f7f',\n      // Gray\n      '#17becf',\n      // Turquoise\n      '#9467bd' // Purple\n      ];\n    }\n    createChainPerformanceChart(dataset) {\n      return new Chart('PerformanceChart', {\n        type: 'bar',\n        data: {\n          datasets: [dataset]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          scales: {\n            y: {\n              beginAtZero: true,\n              alignToPixels: true,\n              grid: {\n                color: 'rgba(0, 0, 0, 0.1)'\n              },\n              ticks: {\n                callback: function (value) {\n                  return value.toLocaleString('en-US', {\n                    minimumFractionDigits: 0\n                  });\n                }\n              }\n            },\n            x: {\n              type: 'category',\n              // Ensuring it's a categorical axis\n              alignToPixels: true,\n              grid: {\n                color: 'rgba(0, 0, 0, 0.1)'\n              }\n            }\n          },\n          plugins: {\n            tooltip: {\n              backgroundColor: 'rgba(0, 0, 0, 0.7)',\n              bodyFont: {\n                size: 14\n              },\n              titleFont: {\n                size: 16,\n                weight: 'bold'\n              },\n              callbacks: {\n                label: function (context) {\n                  const value = context.raw;\n                  return context.dataset.label + ': ' + value.y.toLocaleString('en-US', {\n                    minimumFractionDigits: 2\n                  });\n                }\n              }\n            },\n            legend: {\n              display: false\n            }\n          },\n          elements: {\n            bar: {\n              borderWidth: 0,\n              borderRadius: 4,\n              // Adds rounded corners\n              borderSkipped: false\n            }\n          }\n        }\n      });\n    }\n    createPerformanceChart(datasets) {\n      return new Chart('PerformanceChart', {\n        type: 'bar',\n        data: {\n          datasets: datasets\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          scales: {\n            y: {\n              beginAtZero: true,\n              stacked: true,\n              alignToPixels: true,\n              grid: {\n                color: 'rgba(0, 0, 0, 0.1)'\n              },\n              ticks: {\n                callback: function (value) {\n                  return value.toLocaleString('en-US', {\n                    minimumFractionDigits: 0\n                  });\n                }\n              }\n            },\n            x: {\n              type: 'time',\n              stacked: true,\n              alignToPixels: true,\n              time: {\n                unit: 'week'\n              },\n              grid: {\n                color: 'rgba(0, 0, 0, 0.1)'\n              }\n            }\n          },\n          plugins: {\n            tooltip: {\n              backgroundColor: 'rgba(0, 0, 0, 0.7)',\n              bodyFont: {\n                size: 14\n              },\n              titleFont: {\n                size: 16,\n                weight: 'bold'\n              },\n              callbacks: {\n                label: function (context) {\n                  const value = context.raw;\n                  return context.dataset.label + ': ' + value.y.toLocaleString('en-US', {\n                    minimumFractionDigits: 2\n                  });\n                }\n              }\n            },\n            legend: {\n              display: false\n            }\n          },\n          elements: {\n            bar: {\n              borderWidth: 0,\n              borderRadius: 0,\n              borderSkipped: false\n            }\n          }\n        }\n      });\n    }\n    createStatisticsChart(rewardsChart, nDataSets, tensions) {\n      const dataSets = [];\n      for (let i = 0; i < nDataSets; i++) {\n        let chartColor = 'rgba(138, 128, 128)';\n        if (i > 0) {\n          chartColor = this.chartColors[i - 1];\n        }\n        dataSets.push({\n          label: 'Total rewards earned (RSN)',\n          data: rewardsChart,\n          borderColor: chartColor,\n          borderWidth: 4,\n          pointBackgroundColor: chartColor,\n          cubicInterpolationMode: 'default',\n          tension: tensions[i],\n          pointRadius: 0\n        });\n      }\n      return new Chart('RewardChart', {\n        type: 'line',\n        data: {\n          datasets: dataSets\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          animation: {\n            duration: 0\n          },\n          scales: {\n            y: {\n              grid: {\n                color: 'rgba(0, 0, 0, 0.1)'\n              },\n              ticks: {\n                callback: function (value) {\n                  return value;\n                }\n              }\n            },\n            x: {\n              type: 'time',\n              time: {\n                unit: 'day'\n              },\n              grid: {\n                color: 'rgba(0, 0, 0, 0.1)'\n              }\n            }\n          },\n          plugins: {\n            tooltip: {\n              backgroundColor: 'rgba(0, 0, 0, 0.7)',\n              bodyFont: {\n                size: 14\n              },\n              titleFont: {\n                size: 16,\n                weight: 'bold'\n              }\n            },\n            legend: {\n              labels: {\n                font: {\n                  size: 14\n                }\n              }\n            }\n          }\n        }\n      });\n    }\n    calculateTriangleArea(p1, p2, p3) {\n      return Math.abs((p1.x.getTime() * (p2.y - p3.y) + p2.x.getTime() * (p3.y - p1.y) + p3.x.getTime() * (p1.y - p2.y)) / 2);\n    }\n    reduceChartData(data, targetPoints, adaptExtremes) {\n      if (data.length == 0) {\n        return [];\n      }\n      let points = data.slice();\n      let remainingPoints = points.length - targetPoints;\n      while (remainingPoints > 0) {\n        let minArea = Infinity;\n        let indexToRemove = -1;\n        for (let i = 1; i < points.length - 1; i++) {\n          const area = this.calculateTriangleArea(points[i - 1], points[i], points[i + 1]);\n          if (area < minArea) {\n            minArea = area;\n            indexToRemove = i;\n          }\n        }\n        if (indexToRemove !== -1) {\n          points.splice(indexToRemove, 1);\n          remainingPoints--;\n        } else {\n          break;\n        }\n      }\n      if (!adaptExtremes) {\n        return points;\n      }\n      const timeValuesX = points.map(p => p.x.getTime());\n      const minTimeX = Math.min(...timeValuesX);\n      const maxTimeX = Math.max(...timeValuesX);\n      const timeRangeX = maxTimeX - minTimeX;\n      const newPoints = [];\n      newPoints[0] = points[0];\n      const valuesY = points.map(p => p.y);\n      const minY = Math.min(...valuesY);\n      const maxY = Math.max(...valuesY);\n      const rangeY = maxY - minY;\n      let currentPoint = 0;\n      for (let i = 1; i < points.length; i++) {\n        const diff = points[i].y - points[i - 1].y;\n        const timeDiff = points[i].x.getTime() - points[currentPoint].x.getTime();\n        const dx = timeDiff / timeRangeX;\n        const dy = diff / rangeY;\n        const steepSlope = dx < 0.1 * dy || dy < 0.1 * dx;\n        if (!steepSlope) {\n          newPoints.push(points[i]);\n          currentPoint = i;\n        } else if (i == points.length - 1) {\n          newPoints[newPoints.length - 1] = points[i];\n        }\n      }\n      points = newPoints;\n      if (points.length <= 1 && data.length > 1) {\n        points = [data[0], data[data.length - 1]];\n      }\n      return points;\n    }\n    static {\n      this.ɵfac = function ChartService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || ChartService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: ChartService,\n        factory: ChartService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return ChartService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}