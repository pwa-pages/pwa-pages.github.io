import { Directive, Inject, Input, Output, EventEmitter } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { Dir } from '@angular/cdk/bidi';
import { getRtlScrollAxisType, RtlScrollAxisType } from '@angular/cdk/platform';
import { Observable, Subject, of, take, merge, expand, fromEvent, switchMap, takeUntil, takeWhile, finalize } from 'rxjs';
import BezierEasing from './bezier-easing';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/bidi";
export class SmoothScroll {
    get _w() {
        return this._document.defaultView;
    }
    /**
     * Timing method
     */
    get _now() {
        return this._w.performance?.now?.bind(this._w.performance) || Date.now;
    }
    set smoothScroll(value) {
        if (value) {
            this._zone.runOutsideAngular(() => {
                this.scrollTo(value);
            });
        }
    }
    constructor(_document, _zone, _dir, _el) {
        this._document = _document;
        this._zone = _zone;
        this._dir = _dir;
        this._scrollController = new Subject();
        this._finished = new Subject();
        this.isScrollingChange = new EventEmitter();
        this._el = _el.nativeElement;
    }
    ngOnInit() {
        this._subscription = this._scrollController.pipe(switchMap((context) => {
            this._zone.run(() => {
                this.isScrollingChange.emit(true);
            });
            this._el.classList.add('g-scrolling');
            this._el.style.setProperty('--slider-scroll-snap-type', 'none');
            // Scroll each step recursively
            return of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext)), takeUntil(this._finished))), finalize(() => this.resetElement()), takeUntil(this._interrupted()));
        })).subscribe();
    }
    ngOnDestroy() {
        this._subscription?.unsubscribe();
        this._scrollController.complete();
    }
    /**
     * changes scroll position inside an element
     */
    _scrollElement(x, y) {
        this._el.scrollLeft = x;
        this._el.scrollTop = y;
    }
    resetElement() {
        this._zone.run(() => {
            this.isScrollingChange.emit(false);
        });
        this._el.classList.remove('g-scrolling');
        if (!this._isInterruptedByMouse) {
            this._el.style.setProperty('--slider-scroll-snap-type', this.adapter.scrollSnapType);
        }
        this._isInterruptedByMouse = false;
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    _isFinished(context) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        this._finished.next();
        return false;
    }
    /**
     * Terminates an ongoing smooth scroll
     */
    _interrupted() {
        let interrupt$;
        if (this.interruptOnMousemove && typeof Hammer !== 'undefined') {
            this._hammer = new Hammer(this._el, { inputClass: Hammer.MouseInput });
            this._hammer.get('pan').set({ direction: this.adapter.hammerDirection });
            // For gallery thumb slider, dragging thumbnails should cancel the ongoing scroll
            interrupt$ = merge(new Observable((subscriber) => {
                this._hammer.on('panstart', () => {
                    this._isInterruptedByMouse = true;
                    subscriber.next();
                    subscriber.complete();
                });
                return () => {
                    this._hammer.destroy();
                };
            }), fromEvent(this._el, 'wheel', { passive: true, capture: true }), fromEvent(this._el, 'touchmove', { passive: true, capture: true }));
        }
        else {
            interrupt$ = merge(fromEvent(this._el, 'wheel', { passive: true, capture: true }), fromEvent(this._el, 'touchmove', { passive: true, capture: true }));
        }
        return interrupt$.pipe(take(1));
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    _step(context) {
        return new Observable((subscriber) => {
            let elapsed = (this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this._scrollElement(context.currentX, context.currentY);
            // Proceed to the step
            requestAnimationFrame(() => {
                subscriber.next(context);
                subscriber.complete();
            });
        });
    }
    _applyScrollToOptions(options) {
        if (!options.duration) {
            this._scrollElement(options.left, options.top);
        }
        const context = {
            scrollable: this._el,
            startTime: this._now(),
            startX: this._el.scrollLeft,
            startY: this._el.scrollTop,
            x: options.left == null ? this._el.scrollLeft : ~~options.left,
            y: options.top == null ? this._el.scrollTop : ~~options.top,
            duration: options.duration,
            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
        };
        this._scrollController.next(context);
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param params specified the offsets to scroll to.
     */
    scrollTo(params) {
        const isRtl = this._dir.value === 'rtl';
        const rtlScrollAxisType = getRtlScrollAxisType();
        const options = {
            ...params,
            ...{
                // Rewrite start & end offsets as right or left offsets.
                left: params.left == null ? (isRtl ? params.end : params.start) : params.left,
                right: params.right == null ? (isRtl ? params.start : params.end) : params.right
            },
            duration: params.behavior === 'smooth' ? this.config.scrollDuration : 0,
            easing: this.config.scrollEase,
        };
        // Rewrite the bottom offset as a top offset.
        if (options.bottom != null) {
            options.top = this._el.scrollHeight - this._el.clientHeight - options.bottom;
        }
        // Rewrite the right offset as a left offset.
        if (isRtl && rtlScrollAxisType !== RtlScrollAxisType.NORMAL) {
            if (options.left != null) {
                options.right = this._el.scrollWidth - this._el.clientWidth - options.left;
            }
            if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                options.left = options.right;
            }
            else if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                options.left = options.right ? -options.right : options.right;
            }
        }
        else {
            if (options.right != null) {
                options.left = this._el.scrollWidth - this._el.clientWidth - options.right;
            }
        }
        return this._applyScrollToOptions(options);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: SmoothScroll, deps: [{ token: DOCUMENT }, { token: i0.NgZone }, { token: i1.Dir }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: SmoothScroll, isStandalone: true, selector: "[smoothScroll]", inputs: { smoothScroll: "smoothScroll", adapter: "adapter", config: "config", interruptOnMousemove: ["smoothScrollInterruptOnMousemove", "interruptOnMousemove"] }, outputs: { isScrollingChange: "isScrollingChange" }, providers: [Dir], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: SmoothScroll, decorators: [{
            type: Directive,
            args: [{
                    selector: '[smoothScroll]',
                    standalone: true,
                    providers: [Dir]
                }]
        }], ctorParameters: () => [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.NgZone }, { type: i1.Dir }, { type: i0.ElementRef }], propDecorators: { smoothScroll: [{
                type: Input
            }], adapter: [{
                type: Input
            }], config: [{
                type: Input
            }], interruptOnMousemove: [{
                type: Input,
                args: ['smoothScrollInterruptOnMousemove']
            }], isScrollingChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1nYWxsZXJ5L3NyYy9saWIvc21vb3RoLXNjcm9sbC9zbW9vdGgtc2Nyb2xsLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULE1BQU0sRUFDTixLQUFLLEVBQ0wsTUFBTSxFQUtOLFlBQVksRUFDYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRXhDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ2hGLE9BQU8sRUFDTCxVQUFVLEVBQ1YsT0FBTyxFQUdQLEVBQUUsRUFDRixJQUFJLEVBQ0osS0FBSyxFQUNMLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsUUFBUSxFQUNULE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxZQUFZLE1BQU0saUJBQWlCLENBQUM7OztBQVkzQyxNQUFNLE9BQU8sWUFBWTtJQWV2QixJQUFZLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVksSUFBSTtRQUNkLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDekUsQ0FBQztJQUVELElBQ0ksWUFBWSxDQUFDLEtBQTBCO1FBQ3pDLElBQUksS0FBSyxFQUFFLENBQUM7WUFDVixJQUFJLENBQUMsS0FBSyxDQUFD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Q0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFDM0csQ0FBQztRQUNILENBQUM7UUFDRCxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM3QyxDQUFDOzhHQXZPVSxZQUFZLGtCQTJDSCxRQUFRO2tHQTNDakIsWUFBWSxzUkFGWixDQUFDLEdBQUcsQ0FBQzs7MkZBRUwsWUFBWTtrQkFMeEIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsZ0JBQWdCO29CQUMxQixVQUFVLEVBQUUsSUFBSTtvQkFDaEIsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDO2lCQUNqQjs7MEJBNENjLE1BQU07MkJBQUMsUUFBUTt5R0FoQnhCLFlBQVk7c0JBRGYsS0FBSztnQkFTRyxPQUFPO3NCQUFmLEtBQUs7Z0JBRUcsTUFBTTtzQkFBZCxLQUFLO2dCQUVxQyxvQkFBb0I7c0JBQTlELEtBQUs7dUJBQUMsa0NBQWtDO2dCQUUvQixpQkFBaUI7c0JBQTFCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIERpcmVjdGl2ZSxcclxuICBJbmplY3QsXHJcbiAgSW5wdXQsXHJcbiAgT3V0cHV0LFxyXG4gIE5nWm9uZSxcclxuICBPbkluaXQsXHJcbiAgT25EZXN0cm95LFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgRXZlbnRFbWl0dGVyXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgRGlyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xyXG5pbXBvcnQgeyBfQm90dG9tLCBfTGVmdCwgX1JpZ2h0LCBfVG9wLCBfV2l0aG91dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zY3JvbGxpbmcnO1xyXG5pbXBvcnQgeyBnZXRSdGxTY3JvbGxBeGlzVHlwZSwgUnRsU2Nyb2xsQXhpc1R5cGUgfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xyXG5pbXBvcnQge1xyXG4gIE9ic2VydmFibGUsXHJcbiAgU3ViamVjdCxcclxuICBTdWJzY3JpYmVyLFxyXG4gIFN1YnNjcmlwdGlvbixcclxuICBvZixcclxuICB0YWtlLFxyXG4gIG1lcmdlLFxyXG4gIGV4cGFuZCxcclxuICBmcm9tRXZlbnQsXHJcbiAgc3dpdGNoTWFwLFxyXG4gIHRha2VVbnRpbCxcclxuICB0YWtlV2hpbGUsXHJcbiAgZmluYWxpemVcclxufSBmcm9tICdyeGpzJztcclxuaW1wb3J0IEJlemllckVhc2luZyBmcm9tICcuL2Jlemllci1lYXNpbmcnO1xyXG5pbXBvcnQgeyBHYWxsZXJ5Q29uZmlnIH0gZnJvbSAnLi4vbW9kZWxzL2NvbmZpZy5tb2RlbCc7XHJcbmltcG9ydCB7IFNtb290aFNjcm9sbE9wdGlvbnMsIFNtb290aFNjcm9sbFN0ZXAsIFNtb290aFNjcm9sbFRvT3B0aW9ucyB9IGZyb20gJy4vaW5kZXgnO1xyXG5pbXBvcnQgeyBTbGlkZXJBZGFwdGVyIH0gZnJvbSAnLi4vY29tcG9uZW50cy9hZGFwdGVycyc7XHJcblxyXG5kZWNsYXJlIGNvbnN0IEhhbW1lcjogYW55O1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbc21vb3RoU2Nyb2xsXScsXHJcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcclxuICBwcm92aWRlcnM6IFtEaXJdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTbW9vdGhTY3JvbGwgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gIC8qKiBIYW1tZXJKUyBpbnN0YW5jZSAqL1xyXG4gIHByaXZhdGUgX2hhbW1lcjogYW55O1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IF9zY3JvbGxDb250cm9sbGVyOiBTdWJqZWN0PFNtb290aFNjcm9sbFN0ZXA+ID0gbmV3IFN1YmplY3Q8U21vb3RoU2Nyb2xsU3RlcD4oKTtcclxuXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfZmluaXNoZWQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IF9lbDogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIHByaXZhdGUgX2lzSW50ZXJydXB0ZWRCeU1vdXNlOiBib29sZWFuO1xyXG5cclxuICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgcHJpdmF0ZSBnZXQgX3coKTogV2luZG93IHtcclxuICAgIHJldHVybiB0aGlzLl9kb2N1bWVudC5kZWZhdWx0VmlldztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRpbWluZyBtZXRob2RcclxuICAgKi9cclxuICBwcml2YXRlIGdldCBfbm93KCk6ICgpID0+IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fdy5wZXJmb3JtYW5jZT8ubm93Py5iaW5kKHRoaXMuX3cucGVyZm9ybWFuY2UpIHx8IERhdGUubm93O1xyXG4gIH1cclxuXHJcbiAgQElucHV0KClcclxuICBzZXQgc21vb3RoU2Nyb2xsKHZhbHVlOiBTbW9vdGhTY3JvbGxPcHRpb25zKSB7XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxUbyh2YWx1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQElucHV0KCkgYWRhcHRlcjogU2xpZGVyQWRhcHRlcjtcclxuXHJcbiAgQElucHV0KCkgY29uZmlnOiBHYWxsZXJ5Q29uZmlnO1xyXG5cclxuICBASW5wdXQoJ3Ntb290aFNjcm9sbEludGVycnVwdE9uTW91c2Vtb3ZlJykgaW50ZXJydXB0T25Nb3VzZW1vdmU6IGJvb2xlYW47XHJcblxyXG4gIEBPdXRwdXQoKSBpc1Njcm9sbGluZ0NoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogRG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lLFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgX2RpcjogRGlyLFxyXG4gICAgICAgICAgICAgIF9lbDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4pIHtcclxuICAgIHRoaXMuX2VsID0gX2VsLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3Njcm9sbENvbnRyb2xsZXIucGlwZShcclxuICAgICAgc3dpdGNoTWFwKChjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5pc1Njcm9sbGluZ0NoYW5nZS5lbWl0KHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLl9lbC5jbGFzc0xpc3QuYWRkKCdnLXNjcm9sbGluZycpO1xyXG4gICAgICAgIHRoaXMuX2VsLnN0eWxlLnNldFByb3BlcnR5KCctLXNsaWRlci1zY3JvbGwtc25hcC10eXBlJywgJ25vbmUnKTtcclxuXHJcbiAgICAgICAgLy8gU2Nyb2xsIGVhY2ggc3RlcCByZWN1cnNpdmVseVxyXG4gICAgICAgIHJldHVybiBvZihudWxsKS5waXBlKFxyXG4gICAgICAgICAgZXhwYW5kKCgpID0+IHRoaXMuX3N0ZXAoY29udGV4dCkucGlwZShcclxuICAgICAgICAgICAgdGFrZVdoaWxlKChjdXJyQ29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCkgPT4gdGhpcy5faXNGaW5pc2hlZChjdXJyQ29udGV4dCkpLFxyXG4gICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fZmluaXNoZWQpXHJcbiAgICAgICAgICApKSxcclxuICAgICAgICAgIGZpbmFsaXplKCgpID0+IHRoaXMucmVzZXRFbGVtZW50KCkpLFxyXG4gICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2ludGVycnVwdGVkKCkpLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pXHJcbiAgICApLnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XHJcbiAgICB0aGlzLl9zY3JvbGxDb250cm9sbGVyLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjaGFuZ2VzIHNjcm9sbCBwb3NpdGlvbiBpbnNpZGUgYW4gZWxlbWVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3Njcm9sbEVsZW1lbnQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMuX2VsLnNjcm9sbExlZnQgPSB4O1xyXG4gICAgdGhpcy5fZWwuc2Nyb2xsVG9wID0geTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVzZXRFbGVtZW50KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nQ2hhbmdlLmVtaXQoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fZWwuY2xhc3NMaXN0LnJlbW92ZSgnZy1zY3JvbGxpbmcnKTtcclxuICAgIGlmICghdGhpcy5faXNJbnRlcnJ1cHRlZEJ5TW91c2UpIHtcclxuICAgICAgdGhpcy5fZWwuc3R5bGUuc2V0UHJvcGVydHkoJy0tc2xpZGVyLXNjcm9sbC1zbmFwLXR5cGUnLCB0aGlzLmFkYXB0ZXIuc2Nyb2xsU25hcFR5cGUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5faXNJbnRlcnJ1cHRlZEJ5TW91c2UgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBzbW9vdGggc2Nyb2xsIGhhcyByZWFjaGVkLCBjbGVhbnMgdXAgdGhlIHNtb290aCBzY3JvbGwgc3RyZWFtIGFuZCByZXNvbHZlcyBpdHMgcHJvbWlzZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2lzRmluaXNoZWQoY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGNvbnRleHQuY3VycmVudFggIT09IGNvbnRleHQueCB8fCBjb250ZXh0LmN1cnJlbnRZICE9PSBjb250ZXh0LnkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9maW5pc2hlZC5uZXh0KCk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXJtaW5hdGVzIGFuIG9uZ29pbmcgc21vb3RoIHNjcm9sbFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2ludGVycnVwdGVkKCk6IE9ic2VydmFibGU8RXZlbnQgfCB2b2lkPiB7XHJcbiAgICBsZXQgaW50ZXJydXB0JDogT2JzZXJ2YWJsZTxFdmVudCB8IHZvaWQ+O1xyXG4gICAgaWYgKHRoaXMuaW50ZXJydXB0T25Nb3VzZW1vdmUgJiYgdHlwZW9mIEhhbW1lciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdGhpcy5faGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLl9lbCwgeyBpbnB1dENsYXNzOiBIYW1tZXIuTW91c2VJbnB1dCB9KTtcclxuICAgICAgdGhpcy5faGFtbWVyLmdldCgncGFuJykuc2V0KHsgZGlyZWN0aW9uOiB0aGlzLmFkYXB0ZXIuaGFtbWVyRGlyZWN0aW9uIH0pO1xyXG5cclxuICAgICAgLy8gRm9yIGdhbGxlcnkgdGh1bWIgc2xpZGVyLCBkcmFnZ2luZyB0aHVtYm5haWxzIHNob3VsZCBjYW5jZWwgdGhlIG9uZ29pbmcgc2Nyb2xsXHJcbiAgICAgIGludGVycnVwdCQgPSBtZXJnZShcclxuICAgICAgICBuZXcgT2JzZXJ2YWJsZTx2b2lkPigoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjx2b2lkPikgPT4ge1xyXG4gICAgICAgICAgdGhpcy5faGFtbWVyLm9uKCdwYW5zdGFydCcsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faXNJbnRlcnJ1cHRlZEJ5TW91c2UgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoKTtcclxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW1tZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbCwgJ3doZWVsJywgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLFxyXG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbCwgJ3RvdWNobW92ZScsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KSxcclxuICAgICAgKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW50ZXJydXB0JCA9IG1lcmdlKFxyXG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbCwgJ3doZWVsJywgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLFxyXG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbCwgJ3RvdWNobW92ZScsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KSxcclxuICAgICAgKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGludGVycnVwdCQucGlwZSh0YWtlKDEpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgZnVuY3Rpb24gY2FsbGVkIHJlY3Vyc2l2ZWx5IHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcclxuICAgKi9cclxuICBwcml2YXRlIF9zdGVwKGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXApOiBPYnNlcnZhYmxlPFNtb290aFNjcm9sbFN0ZXA+IHtcclxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxTbW9vdGhTY3JvbGxTdGVwPikgPT4ge1xyXG4gICAgICBsZXQgZWxhcHNlZDogbnVtYmVyID0gKHRoaXMuX25vdygpIC0gY29udGV4dC5zdGFydFRpbWUpIC8gY29udGV4dC5kdXJhdGlvbjtcclxuXHJcbiAgICAgIC8vIGF2b2lkIGVsYXBzZWQgdGltZXMgaGlnaGVyIHRoYW4gb25lXHJcbiAgICAgIGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xyXG5cclxuICAgICAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxyXG4gICAgICBjb25zdCB2YWx1ZTogbnVtYmVyID0gY29udGV4dC5lYXNpbmcoZWxhcHNlZCk7XHJcblxyXG4gICAgICBjb250ZXh0LmN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XHJcbiAgICAgIGNvbnRleHQuY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcclxuXHJcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQoY29udGV4dC5jdXJyZW50WCwgY29udGV4dC5jdXJyZW50WSk7XHJcbiAgICAgIC8vIFByb2NlZWQgdG8gdGhlIHN0ZXBcclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICBzdWJzY3JpYmVyLm5leHQoY29udGV4dCk7XHJcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfYXBwbHlTY3JvbGxUb09wdGlvbnMob3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogdm9pZCB7XHJcbiAgICBpZiAoIW9wdGlvbnMuZHVyYXRpb24pIHtcclxuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudChvcHRpb25zLmxlZnQsIG9wdGlvbnMudG9wKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwID0ge1xyXG4gICAgICBzY3JvbGxhYmxlOiB0aGlzLl9lbCxcclxuICAgICAgc3RhcnRUaW1lOiB0aGlzLl9ub3coKSxcclxuICAgICAgc3RhcnRYOiB0aGlzLl9lbC5zY3JvbGxMZWZ0LFxyXG4gICAgICBzdGFydFk6IHRoaXMuX2VsLnNjcm9sbFRvcCxcclxuICAgICAgeDogb3B0aW9ucy5sZWZ0ID09IG51bGwgPyB0aGlzLl9lbC5zY3JvbGxMZWZ0IDogfn5vcHRpb25zLmxlZnQsXHJcbiAgICAgIHk6IG9wdGlvbnMudG9wID09IG51bGwgPyB0aGlzLl9lbC5zY3JvbGxUb3AgOiB+fm9wdGlvbnMudG9wLFxyXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcclxuICAgICAgZWFzaW5nOiBCZXppZXJFYXNpbmcob3B0aW9ucy5lYXNpbmcueDEsIG9wdGlvbnMuZWFzaW5nLnkxLCBvcHRpb25zLmVhc2luZy54Miwgb3B0aW9ucy5lYXNpbmcueTIpXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX3Njcm9sbENvbnRyb2xsZXIubmV4dChjb250ZXh0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBvZmZzZXRzLiBUaGlzIGlzIGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNjcm9sbFRvXHJcbiAgICogbWV0aG9kLCBzaW5jZSBicm93c2VycyBhcmUgbm90IGNvbnNpc3RlbnQgYWJvdXQgd2hhdCBzY3JvbGxMZWZ0IG1lYW5zIGluIFJUTC4gRm9yIHRoaXMgbWV0aG9kXHJcbiAgICogbGVmdCBhbmQgcmlnaHQgYWx3YXlzIHJlZmVyIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyIGlycmVzcGVjdGl2ZVxyXG4gICAqIG9mIHRoZSBsYXlvdXQgZGlyZWN0aW9uLiBzdGFydCBhbmQgZW5kIHJlZmVyIHRvIGxlZnQgYW5kIHJpZ2h0IGluIGFuIExUUiBjb250ZXh0IGFuZCB2aWNlLXZlcnNhXHJcbiAgICogaW4gYW4gUlRMIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHBhcmFtcyBzcGVjaWZpZWQgdGhlIG9mZnNldHMgdG8gc2Nyb2xsIHRvLlxyXG4gICAqL1xyXG4gIHNjcm9sbFRvKHBhcmFtczogU21vb3RoU2Nyb2xsT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgY29uc3QgaXNSdGw6IGJvb2xlYW4gPSB0aGlzLl9kaXIudmFsdWUgPT09ICdydGwnO1xyXG4gICAgY29uc3QgcnRsU2Nyb2xsQXhpc1R5cGU6IFJ0bFNjcm9sbEF4aXNUeXBlID0gZ2V0UnRsU2Nyb2xsQXhpc1R5cGUoKTtcclxuXHJcbiAgICBjb25zdCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XHJcbiAgICAgIC4uLnBhcmFtcyxcclxuICAgICAgLi4uKHtcclxuICAgICAgICAvLyBSZXdyaXRlIHN0YXJ0ICYgZW5kIG9mZnNldHMgYXMgcmlnaHQgb3IgbGVmdCBvZmZzZXRzLlxyXG4gICAgICAgIGxlZnQ6IHBhcmFtcy5sZWZ0ID09IG51bGwgPyAoaXNSdGwgPyBwYXJhbXMuZW5kIDogcGFyYW1zLnN0YXJ0KSA6IHBhcmFtcy5sZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiBwYXJhbXMucmlnaHQgPT0gbnVsbCA/IChpc1J0bCA/IHBhcmFtcy5zdGFydCA6IHBhcmFtcy5lbmQpIDogcGFyYW1zLnJpZ2h0XHJcbiAgICAgIH0gYXMgX1dpdGhvdXQ8X0JvdHRvbSAmIF9Ub3A+KSxcclxuICAgICAgZHVyYXRpb246IHBhcmFtcy5iZWhhdmlvciA9PT0gJ3Ntb290aCcgPyB0aGlzLmNvbmZpZy5zY3JvbGxEdXJhdGlvbiA6IDAsXHJcbiAgICAgIGVhc2luZzogdGhpcy5jb25maWcuc2Nyb2xsRWFzZSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmV3cml0ZSB0aGUgYm90dG9tIG9mZnNldCBhcyBhIHRvcCBvZmZzZXQuXHJcbiAgICBpZiAob3B0aW9ucy5ib3R0b20gIT0gbnVsbCkge1xyXG4gICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfQm90dG9tPiAmIF9Ub3ApLnRvcCA9IHRoaXMuX2VsLnNjcm9sbEhlaWdodCAtIHRoaXMuX2VsLmNsaWVudEhlaWdodCAtIG9wdGlvbnMuYm90dG9tO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJld3JpdGUgdGhlIHJpZ2h0IG9mZnNldCBhcyBhIGxlZnQgb2Zmc2V0LlxyXG4gICAgaWYgKGlzUnRsICYmIHJ0bFNjcm9sbEF4aXNUeXBlICE9PSBSdGxTY3JvbGxBeGlzVHlwZS5OT1JNQUwpIHtcclxuICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPSBudWxsKSB7XHJcbiAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X0xlZnQ+ICYgX1JpZ2h0KS5yaWdodCA9IHRoaXMuX2VsLnNjcm9sbFdpZHRoIC0gdGhpcy5fZWwuY2xpZW50V2lkdGggLSBvcHRpb25zLmxlZnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuSU5WRVJURUQpIHtcclxuICAgICAgICBvcHRpb25zLmxlZnQgPSBvcHRpb25zLnJpZ2h0O1xyXG4gICAgICB9IGVsc2UgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5ORUdBVEVEKSB7XHJcbiAgICAgICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5yaWdodCA/IC1vcHRpb25zLnJpZ2h0IDogb3B0aW9ucy5yaWdodDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKG9wdGlvbnMucmlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgIChvcHRpb25zIGFzIF9XaXRob3V0PF9SaWdodD4gJiBfTGVmdCkubGVmdCA9IHRoaXMuX2VsLnNjcm9sbFdpZHRoIC0gdGhpcy5fZWwuY2xpZW50V2lkdGggLSBvcHRpb25zLnJpZ2h0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fYXBwbHlTY3JvbGxUb09wdGlvbnMob3B0aW9ucyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==