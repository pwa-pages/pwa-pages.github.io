"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.libraryGenerator = libraryGenerator;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const log_show_project_command_1 = require("@nx/devkit/src/utils/log-show-project-command");
const js_1 = require("@nx/js");
const add_release_config_1 = require("@nx/js/src/generators/library/utils/add-release-config");
const init_1 = tslib_1.__importDefault(require("../../generators/init/init"));
const test_runners_1 = require("../../utils/test-runners");
const add_linting_1 = tslib_1.__importDefault(require("../add-linting/add-linting"));
const setup_tailwind_1 = tslib_1.__importDefault(require("../setup-tailwind/setup-tailwind"));
const add_jest_1 = require("../utils/add-jest");
const add_vitest_1 = require("../utils/add-vitest");
const dependencies_1 = require("../utils/dependencies");
const ensure_angular_dependencies_1 = require("../utils/ensure-angular-dependencies");
const validations_1 = require("../utils/validations");
const version_utils_1 = require("../utils/version-utils");
const add_module_1 = require("./lib/add-module");
const add_project_1 = require("./lib/add-project");
const add_standalone_component_1 = require("./lib/add-standalone-component");
const create_files_1 = require("./lib/create-files");
const normalize_options_1 = require("./lib/normalize-options");
const set_generator_defaults_1 = require("./lib/set-generator-defaults");
const update_lib_package_npm_scope_1 = require("./lib/update-lib-package-npm-scope");
const update_tsconfig_files_1 = require("./lib/update-tsconfig-files");
async function libraryGenerator(tree, schema) {
    (0, validations_1.assertNotUsingTsSolutionSetup)(tree, 'library');
    // Do some validation checks
    if (!schema.routing && schema.lazy) {
        throw new Error(`To use "--lazy" option, "--routing" must also be set.`);
    }
    if (schema.publishable === true && !schema.importPath) {
        throw new Error(`For publishable libs you have to provide a proper "--importPath" which needs to be a valid npm package name (e.g. my-awesome-lib or @myorg/my-lib)`);
    }
    if (schema.addTailwind && !schema.buildable && !schema.publishable) {
        throw new Error(`To use "--addTailwind" option, you have to set either "--buildable" or "--publishable".`);
    }
    const options = await (0, normalize_options_1.normalizeOptions)(tree, schema);
    const { libraryOptions } = options;
    const pkgVersions = (0, version_utils_1.versions)(tree);
    await (0, js_1.initGenerator)(tree, {
        ...libraryOptions,
        js: false,
        skipFormat: true,
    });
    await (0, init_1.default)(tree, { ...libraryOptions, skipFormat: true });
    if (!libraryOptions.skipPackageJson) {
        (0, ensure_angular_dependencies_1.ensureAngularDependencies)(tree);
    }
    const project = await (0, add_project_1.addProject)(tree, libraryOptions);
    (0, create_files_1.createFiles)(tree, options, project);
    await addUnitTestRunner(tree, libraryOptions);
    (0, update_tsconfig_files_1.updateTsConfigFiles)(tree, libraryOptions);
    updateNpmScopeIfBuildableOrPublishable(tree, libraryOptions);
    (0, set_generator_defaults_1.setGeneratorDefaults)(tree, options);
    if (!libraryOptions.standalone) {
        (0, add_module_1.addModule)(tree, libraryOptions);
    }
    else {
        await (0, add_standalone_component_1.addStandaloneComponent)(tree, options);
    }
    await addLinting(tree, libraryOptions);
    if (libraryOptions.addTailwind) {
        await (0, setup_tailwind_1.default)(tree, {
            project: libraryOptions.name,
            skipFormat: true,
            skipPackageJson: libraryOptions.skipPackageJson,
        });
    }
    if ((libraryOptions.buildable || libraryOptions.publishable) &&
        !libraryOptions.skipPackageJson) {
        (0, devkit_1.addDependenciesToPackageJson)(tree, {}, {
            'ng-packagr': pkgVersions.ngPackagrVersion,
        }, undefined, true);
        (0, dependencies_1.addBuildableLibrariesPostCssDependencies)(tree);
    }
    if (!libraryOptions.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    const tasks = [() => (0, devkit_1.installPackagesTask)(tree)];
    if (libraryOptions.publishable) {
        tasks.push(await (0, add_release_config_1.releaseTasks)(tree));
    }
    tasks.push(() => (0, log_show_project_command_1.logShowProjectCommand)(libraryOptions.name));
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
async function addUnitTestRunner(host, options) {
    switch (options.unitTestRunner) {
        case test_runners_1.UnitTestRunner.Jest:
            await (0, add_jest_1.addJest)(host, {
                name: options.name,
                projectRoot: options.projectRoot,
                skipPackageJson: options.skipPackageJson,
                strict: options.strict,
            });
            break;
        case test_runners_1.UnitTestRunner.Vitest:
            await (0, add_vitest_1.addVitest)(host, {
                name: options.name,
                projectRoot: options.projectRoot,
                skipPackageJson: options.skipPackageJson,
                strict: options.strict,
            });
            break;
    }
}
function updateNpmScopeIfBuildableOrPublishable(host, options) {
    if (options.buildable || options.publishable) {
        (0, update_lib_package_npm_scope_1.updateLibPackageNpmScope)(host, options);
    }
}
async function addLinting(host, options) {
    if (options.linter === 'none') {
        return;
    }
    await (0, add_linting_1.default)(host, {
        projectName: options.name,
        projectRoot: options.projectRoot,
        prefix: options.prefix,
        unitTestRunner: options.unitTestRunner,
        setParserOptionsProject: options.setParserOptionsProject,
        skipFormat: true,
        skipPackageJson: options.skipPackageJson,
    });
}
exports.default = libraryGenerator;
