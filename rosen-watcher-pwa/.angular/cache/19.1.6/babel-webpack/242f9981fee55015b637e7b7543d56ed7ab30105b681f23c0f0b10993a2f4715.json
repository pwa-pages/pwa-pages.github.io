{"ast":null,"code":"import _asyncToGenerator from \"/home/pebblerye/pwa/pwa-pages.github.io/rosen-watcher-pwa/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Address } from '../../service/ts/models/address';\nimport { EventType } from './event.service';\nimport { DateUtils } from '../statistics/date.utils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./storage.service\";\nimport * as i2 from \"./event.service\";\nexport function initializeDataService(dataService) {\n  return () => {\n    return dataService.initialize();\n  };\n}\nexport let DataService = /*#__PURE__*/(() => {\n  class DataService {\n    constructor(storageService, eventService) {\n      this.storageService = storageService;\n      this.eventService = eventService;\n      this.rsnInputs = [];\n      this.addressCharts = {};\n      this.chainChart = {\n        [ChainType.Bitcoin]: {\n          chart: 0\n        },\n        [ChainType.Cardano]: {\n          chart: 0\n        },\n        [ChainType.Ergo]: {\n          chart: 0\n        },\n        [ChainType.Ethereum]: {\n          chart: 0\n        },\n        [ChainType.Binance]: {\n          chart: 0\n        },\n        [ChainType.Doge]: {\n          chart: 0\n        }\n      };\n      this.busyCounter = 0;\n    }\n    initialize() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        _this.eventService.subscribeToEvent(EventType.InputsChanged, /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (i) {\n            _this.rsnInputs = i;\n            _this.eventService.sendEvent(EventType.RefreshInputs);\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n        _this.eventService.subscribeToEvent(EventType.PerfChartChanged, /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (a) {\n            _this.chainChart = a;\n            _this.eventService.sendEvent(EventType.RefreshInputs);\n          });\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n        _this.eventService.subscribeToEvent(EventType.AddressChartChanged, /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* (a) {\n            _this.addressCharts = a;\n            _this.eventService.sendEvent(EventType.RefreshInputs);\n          });\n          return function (_x3) {\n            return _ref3.apply(this, arguments);\n          };\n        }());\n      })();\n    }\n    getInputs() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        return _this2.storageService.getInputs();\n      })();\n    }\n    getInputsPart(size, fromDate, toDate, addresses) {\n      let result = this.getSortedInputs(false, fromDate, toDate);\n      if (result && addresses && addresses.length > 0) {\n        const activeAddresses = addresses.filter(address => address.active).map(address => address.address);\n        result = result.filter(input => activeAddresses.includes(input.outputAddress));\n      }\n      if (size) {\n        result = result.slice(0, size);\n      }\n      return result;\n    }\n    getSortedInputs(ascending, fromDate, toDate) {\n      this.rsnInputs.sort((a, b) => {\n        const aTime = Math.round(a.inputDate.getTime() / 1000) * 1000;\n        const bTime = Math.round(b.inputDate.getTime() / 1000) * 1000;\n        if (aTime !== bTime) {\n          return !ascending ? bTime - aTime : aTime - bTime;\n        }\n        return (b.amount ?? 0) - (a.amount ?? 0);\n      });\n      let result = this.rsnInputs;\n      const stripTimeUTC = DateUtils.StripTimeUTC();\n      const fromDateUTC = DateUtils.convertToUTCWithSameFields(fromDate);\n      const toDateUTC = DateUtils.convertToUTCWithSameFields(toDate);\n      result = result.filter(i => {\n        const inputDateStripped = stripTimeUTC(i.inputDate);\n        return (!fromDateUTC || inputDateStripped >= fromDateUTC) && (!toDateUTC || inputDateStripped <= toDateUTC);\n      });\n      return result;\n    }\n    getAddressCharts() {\n      return this.addressCharts;\n    }\n    getChainChart() {\n      return this.chainChart;\n    }\n    getAddresses() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        return yield _this3.storageService.getAddressData();\n      })();\n    }\n    getAddressesForDisplay(inputs) {\n      const addresses = this.getAddressesFromInputs(inputs);\n      addresses.sort((a, b) => (a.chainType ?? '').localeCompare(b.chainType ?? ''));\n      return addresses;\n    }\n    getAddressesFromInputs(inputs) {\n      const addresses = [];\n      const existingAddresses = new Set(addresses.map(a => a.address));\n      inputs.forEach(input => {\n        if (!existingAddresses.has(input.outputAddress)) {\n          const newAddress = new Address(input.outputAddress, input.chainType ?? null);\n          addresses.push(newAddress);\n          existingAddresses.add(input.outputAddress);\n        }\n      });\n      return addresses;\n    }\n    static {\n      this.ɵfac = function DataService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || DataService)(i0.ɵɵinject(i1.StorageService), i0.ɵɵinject(i2.EventService));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: DataService,\n        factory: DataService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return DataService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}