{"ast":null,"code":"import _asyncToGenerator from \"/home/pebblerye/pwa/pwa-pages.github.io/rosen-watcher-pwa/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport '../../shared/ts/constants';\nimport * as i0 from \"@angular/core\";\nexport let StorageService = /*#__PURE__*/(() => {\n  class StorageService {\n    constructor() {\n      this.inputsCache = [];\n      this.profile = null;\n      this.initIndexedDB();\n    }\n    getProfile() {\n      return this.profile;\n    }\n    initIndexedDB(profile = null) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        let dbName = rs_DbName;\n        _this.profile = profile;\n        if (profile) {\n          dbName = dbName + '_' + profile;\n        }\n        _this.dbPromise = new Promise((resolve, reject) => {\n          const request = window.indexedDB.open(dbName, rs_DbVersion);\n          request.onupgradeneeded = event => {\n            const db = event.target.result;\n            if (db.objectStoreNames.contains(rs_InputsStoreName)) {\n              db.deleteObjectStore(rs_InputsStoreName);\n            }\n            db.createObjectStore(rs_InputsStoreName, {\n              keyPath: rs_Input_Key\n            });\n            if (db.objectStoreNames.contains(rs_PerfTxStoreName)) {\n              db.deleteObjectStore(rs_PerfTxStoreName);\n            }\n            db.createObjectStore(rs_PerfTxStoreName, {\n              keyPath: rs_PerfTx_Key\n            });\n            if (!db.objectStoreNames.contains(rs_AddressDataStoreName)) {\n              db.createObjectStore(rs_AddressDataStoreName, {\n                keyPath: rs_Address_Key\n              });\n            }\n            if (!db.objectStoreNames.contains(rs_DownloadStatusStoreName)) {\n              db.createObjectStore(rs_DownloadStatusStoreName, {\n                keyPath: rs_Address_Key\n              });\n            }\n          };\n          request.onsuccess = /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (event) {\n              const db = event.target.result;\n              resolve(db);\n            });\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }();\n          request.onerror = event => {\n            console.error('Error opening IndexedDB:', event.target);\n            reject(event.target);\n          };\n        });\n      })();\n    }\n    getDB() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        return yield _this2.dbPromise;\n      })();\n    }\n    clearAddressStore() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        const db = yield _this3.getDB();\n        return new Promise(resolve => {\n          const transaction = db.transaction([rs_AddressDataStoreName], 'readwrite');\n          const objectStore = transaction.objectStore(rs_AddressDataStoreName);\n          const request = objectStore.clear();\n          request.onsuccess = () => {\n            console.log('IndexedDB cleared successfully.');\n            resolve();\n          };\n          request.onerror = event => {\n            console.error('Error clearing IndexedDB:', event.target);\n            resolve();\n          };\n        });\n      })();\n    }\n    clearInputsStore() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const db = yield _this4.getDB();\n        return new Promise(resolve => {\n          const transaction = db.transaction([rs_InputsStoreName], 'readwrite');\n          const objectStore = transaction.objectStore(rs_InputsStoreName);\n          const request = objectStore.clear();\n          request.onsuccess = () => {\n            console.log('IndexedDB cleared successfully.');\n            resolve();\n          };\n          request.onerror = event => {\n            console.error('Error clearing IndexedDB:', event.target);\n            resolve();\n          };\n        });\n      })();\n    }\n    getInputs() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        console.log('Getting inputs from database');\n        _this5.inputsCache = yield _this5.getData(rs_InputsStoreName);\n        return _this5.inputsCache;\n      })();\n    }\n    getAddressData() {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        return yield _this6.getData(rs_AddressDataStoreName);\n      })();\n    }\n    getData(storeName) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        const db = yield _this7.getDB();\n        return new Promise((resolve, reject) => {\n          const transaction = db.transaction([storeName], 'readonly');\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.getAll();\n          request.onsuccess = () => {\n            resolve(request.result);\n          };\n          request.onerror = event => {\n            reject(event.target);\n          };\n        });\n      })();\n    }\n    putAddressData(addressData) {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        if (!addressData) {\n          return;\n        }\n        yield _this8.clearAddressStore();\n        const db = yield _this8.getDB();\n        addressData.forEach(a => {\n          const transaction = db.transaction([rs_AddressDataStoreName], 'readwrite');\n          const objectStore = transaction.objectStore(rs_AddressDataStoreName);\n          a.Address = a.address;\n          objectStore.put(a);\n        });\n      })();\n    }\n    static {\n      this.ɵfac = function StorageService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || StorageService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: StorageService,\n        factory: StorageService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return StorageService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}