import { Directive, Input, Output, EventEmitter } from '@angular/core';
import { of, tap, take, filter, fromEvent, switchMap, debounceTime, firstValueFrom, distinctUntilChanged, EMPTY, animationFrameScheduler } from 'rxjs';
import { resizeObservable } from '../utils/resize-observer';
import * as i0 from "@angular/core";
import * as i1 from "../services/gallery.service";
import * as i2 from "../utils/img-manager";
export class SliderResizeObserver {
    get _viewport() {
        return this._el.nativeElement;
    }
    get _galleryCore() {
        return this._el.nativeElement.parentElement.parentElement.parentElement;
    }
    get _isAutoHeight() {
        return this.config.autoHeight &&
            !this.config.itemAutosize &&
            this.config.orientation === 'horizontal' &&
            (this.config.thumbPosition === 'top' || this.config.thumbPosition === 'bottom');
    }
    constructor(_el, _zone, _gallery, _imgManager) {
        this._el = _el;
        this._zone = _zone;
        this._gallery = _gallery;
        this._imgManager = _imgManager;
        this.isResizingChange = new EventEmitter();
    }
    ngOnInit() {
        const galleryRef = this._gallery.ref(this.galleryId);
        // Check if height has transition for the auto-height feature
        const transitionDuration = getComputedStyle(this._viewport).getPropertyValue('transition-duration');
        if (parseFloat(transitionDuration) === 0) {
            this._afterHeightChanged$ = of(null);
        }
        else {
            this._afterHeightChanged$ = fromEvent(this._viewport, 'transitionend');
        }
        this._zone.runOutsideAngular(() => {
            // Detect if the size of the slider has changed detecting current index on scroll
            this._resizeSubscription = resizeObservable(this._viewport, (observer) => this._resizeObserver = observer).pipe(
            // Check if resize should skip due to re-observing the slider
            filter(() => !this._shouldSkip || !(this._shouldSkip = false)), 
            // Immediately set visibility to hidden to avoid changing the active item caused by appearance of other items when size is expanded
            tap(() => this.setResizingState()), debounceTime(this.config.resizeDebounceTime, animationFrameScheduler), tap(async (entry) => {
                // Update CSS variables with the proper values
                this.updateSliderSize();
                if (this._isAutoHeight) {
                    const img = await firstValueFrom(this._imgManager.getActiveItem(galleryRef.state));
                    // If img height is identical to the viewport height then skip
                    if (img.height === this._viewport.clientHeight) {
                        this.resetResizingState();
                    }
                    else {
                        // Unobserve the slider while the height is being changed
                        this.setResizingState({ unobserve: true });
                        // Change the height
                        this._galleryCore.style.setProperty('--slider-height', `${img.height}px`);
                        // Wait until height transition ends
                        await firstValueFrom(this._afterHeightChanged$);
                        this.resetResizingState({
                            // Mark to skip first emit after re-observing the slider if height content rect height and client height are identical
                            shouldSkip: entry.contentRect.height === this._viewport.clientHeight,
                            observe: true
                        });
                    }
                }
                else {
                    requestAnimationFrame(() => this.resetResizingState({ shouldSkip: true }));
                }
            })).subscribe();
        });
    }
    ngOnChanges() {
        this._isAutoHeight ? this._subscribeAutoHeight() : this._unsubscribeAutoHeight();
    }
    ngOnDestroy() {
        this._resizeSubscription?.unsubscribe();
        this._unsubscribeAutoHeight();
    }
    ngAfterViewChecked() {
        this.updateSliderSize();
    }
    updateSliderSize() {
        // Update slider width and height CSS variables
        this._galleryCore.style.setProperty('--slider-width', `${this._viewport.clientWidth}px`);
        // Only update height if auto-height is false, because when it's true, another function will take care of it
        if (!this.config.autoHeight) {
            this._galleryCore.style.setProperty('--slider-height', `${this._viewport.clientHeight}px`);
        }
        this.updateCentralizeCSSVariables();
    }
    updateCentralizeCSSVariables() {
        if (this.config.itemAutosize) {
            this._galleryCore.style.setProperty('--slider-centralize-start-size', `${this.adapter.getCentralizerStartSize()}px`);
            this._galleryCore.style.setProperty('--slider-centralize-end-size', `${this.adapter.getCentralizerEndSize()}px`);
        }
    }
    _subscribeAutoHeight() {
        this._unsubscribeAutoHeight();
        this._shouldSkip = false;
        this._zone.runOutsideAngular(() => {
            const galleryRef = this._gallery.ref(this.galleryId);
            // TODO: Why is galleryRef.state emits when screen size changes?
            const state = galleryRef.state.pipe(distinctUntilChanged((a, b) => a.currIndex === b.currIndex));
            this._autoHeightSubscription = this._imgManager.getActiveItem(state).pipe(switchMap((img) => {
                this.setResizingState({ unobserve: true });
                this._galleryCore.style.setProperty('--slider-height', `${img.clientHeight}px`);
                // Check if the new item height is equal to the current height, there will be no transition,
                // So reset resizing state
                if (img.height === this._viewport.clientHeight) {
                    this.resetResizingState({ shouldSkip: true, observe: true });
                    return EMPTY;
                }
                return this._afterHeightChanged$.pipe(tap(() => this.resetResizingState({ shouldSkip: true, observe: true })), take(1));
            })).subscribe();
        });
    }
    _unsubscribeAutoHeight() {
        this._autoHeightSubscription?.unsubscribe();
    }
    setResizingState({ unobserve } = {}) {
        this._zone.run(() => {
            this.isResizingChange.emit(true);
        });
        this._viewport.classList.add('g-resizing');
        if (unobserve) {
            // Unobserve the slider while the height is being changed
            this._resizeObserver.unobserve(this._viewport);
        }
    }
    resetResizingState({ shouldSkip, observe } = {}) {
        this._zone.run(() => {
            this.isResizingChange.emit(false);
        });
        this._viewport.classList.remove('g-resizing');
        this._shouldSkip = shouldSkip;
        if (observe) {
            this._resizeObserver.observe(this._viewport);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: SliderResizeObserver, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i1.Gallery }, { token: i2.ImgManager }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: SliderResizeObserver, isStandalone: true, selector: "[sliderResizeObserver]", inputs: { galleryId: "galleryId", adapter: "adapter", config: "config" }, outputs: { isResizingChange: "isResizingChange" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: SliderResizeObserver, decorators: [{
            type: Directive,
            args: [{
                    selector: '[sliderResizeObserver]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i1.Gallery }, { type: i2.ImgManager }], propDecorators: { galleryId: [{
                type: Input
            }], adapter: [{
                type: Input
            }], config: [{
                type: Input
            }], isResizingChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLXJlc2l6ZS1vYnNlcnZlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1nYWxsZXJ5L3NyYy9saWIvb2JzZXJ2ZXJzL3NsaWRlci1yZXNpemUtb2JzZXJ2ZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFPTixZQUFZLEVBQ2IsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUdMLEVBQUUsRUFDRixHQUFHLEVBQ0gsSUFBSSxFQUNKLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNULFlBQVksRUFDWixjQUFjLEVBQ2Qsb0JBQW9CLEVBQ3BCLEtBQUssRUFDTCx1QkFBdUIsRUFDeEIsTUFBTSxNQUFNLENBQUM7QUFFZCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7OztBQVc1RCxNQUFNLE9BQU8sb0JBQW9CO0lBYS9CLElBQVksU0FBUztRQUNuQixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO0lBQ2hDLENBQUM7SUFFRCxJQUFZLFlBQVk7UUFDdEIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQztJQUMxRSxDQUFDO0lBRUQsSUFBWSxhQUFhO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVO1lBQzNCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZO1lBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxLQUFLLFlBQVk7WUFDeEMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLEtBQUssUUFBUSxDQUFDLENBQUM7SUFDcEYsQ0FBQztJQVVELFlBQW9CLEdB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QUFHLENBQUMsR0FBRyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEMsQ0FBQyxDQUFDLENBQUE7UUFDRixJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxVQUFVLENBQUM7UUFDOUIsSUFBSSxPQUFPLEVBQUUsQ0FBQztZQUNaLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvQyxDQUFDO0lBQ0gsQ0FBQzs4R0FsTFUsb0JBQW9CO2tHQUFwQixvQkFBb0I7OzJGQUFwQixvQkFBb0I7a0JBSmhDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLHdCQUF3QjtvQkFDbEMsVUFBVSxFQUFFLElBQUk7aUJBQ2pCO21KQTZCVSxTQUFTO3NCQUFqQixLQUFLO2dCQUVHLE9BQU87c0JBQWYsS0FBSztnQkFFRyxNQUFNO3NCQUFkLEtBQUs7Z0JBRUksZ0JBQWdCO3NCQUF6QixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBEaXJlY3RpdmUsXHJcbiAgSW5wdXQsXHJcbiAgT3V0cHV0LFxyXG4gIE5nWm9uZSxcclxuICBFbGVtZW50UmVmLFxyXG4gIEFmdGVyVmlld0NoZWNrZWQsXHJcbiAgT25Jbml0LFxyXG4gIE9uQ2hhbmdlcyxcclxuICBPbkRlc3Ryb3ksXHJcbiAgRXZlbnRFbWl0dGVyXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7XHJcbiAgT2JzZXJ2YWJsZSxcclxuICBTdWJzY3JpcHRpb24sXHJcbiAgb2YsXHJcbiAgdGFwLFxyXG4gIHRha2UsXHJcbiAgZmlsdGVyLFxyXG4gIGZyb21FdmVudCxcclxuICBzd2l0Y2hNYXAsXHJcbiAgZGVib3VuY2VUaW1lLFxyXG4gIGZpcnN0VmFsdWVGcm9tLFxyXG4gIGRpc3RpbmN0VW50aWxDaGFuZ2VkLFxyXG4gIEVNUFRZLFxyXG4gIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyXHJcbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IEltZ01hbmFnZXIgfSBmcm9tICcuLi91dGlscy9pbWctbWFuYWdlcic7XHJcbmltcG9ydCB7IHJlc2l6ZU9ic2VydmFibGUgfSBmcm9tICcuLi91dGlscy9yZXNpemUtb2JzZXJ2ZXInO1xyXG5pbXBvcnQgeyBTbGlkZXJBZGFwdGVyIH0gZnJvbSAnLi4vY29tcG9uZW50cy9hZGFwdGVycyc7XHJcbmltcG9ydCB7IEdhbGxlcnkgfSBmcm9tICcuLi9zZXJ2aWNlcy9nYWxsZXJ5LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHYWxsZXJ5UmVmIH0gZnJvbSAnLi4vc2VydmljZXMvZ2FsbGVyeS1yZWYnO1xyXG5pbXBvcnQgeyBHYWxsZXJ5Q29uZmlnIH0gZnJvbSAnLi4vbW9kZWxzL2NvbmZpZy5tb2RlbCc7XHJcbmltcG9ydCB7IEdhbGxlcnlTdGF0ZSB9IGZyb20gJy4uL21vZGVscy9nYWxsZXJ5Lm1vZGVsJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW3NsaWRlclJlc2l6ZU9ic2VydmVyXScsXHJcbiAgc3RhbmRhbG9uZTogdHJ1ZVxyXG59KVxyXG5leHBvcnQgY2xhc3MgU2xpZGVyUmVzaXplT2JzZXJ2ZXIgaW1wbGVtZW50cyBBZnRlclZpZXdDaGVja2VkLCBPbkNoYW5nZXMsIE9uSW5pdCwgT25EZXN0cm95IHtcclxuXHJcbiAgcHJpdmF0ZSBfcmVzaXplT2JzZXJ2ZXI6IFJlc2l6ZU9ic2VydmVyO1xyXG5cclxuICBwcml2YXRlIF9hdXRvSGVpZ2h0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcblxyXG4gIHByaXZhdGUgX3Jlc2l6ZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG5cclxuICBwcml2YXRlIF9zaG91bGRTa2lwOiBib29sZWFuO1xyXG5cclxuICAvLyBTdHJlYW0gdGhhdCBlbWl0cyBhZnRlciB0aGUgdHJhbnNpdGlvbiB0byB0aGUgbmV3IGhlaWdodCBpcyBjb21wbGV0ZWRcclxuICBwcml2YXRlIF9hZnRlckhlaWdodENoYW5nZWQkOiBPYnNlcnZhYmxlPGFueT47XHJcblxyXG4gIHByaXZhdGUgZ2V0IF92aWV3cG9ydCgpOiBIVE1MRWxlbWVudCB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWwubmF0aXZlRWxlbWVudDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0IF9nYWxsZXJ5Q29yZSgpOiBIVE1MRWxlbWVudCB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWwubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0IF9pc0F1dG9IZWlnaHQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25maWcuYXV0b0hlaWdodCAmJlxyXG4gICAgICAhdGhpcy5jb25maWcuaXRlbUF1dG9zaXplICYmXHJcbiAgICAgIHRoaXMuY29uZmlnLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgJiZcclxuICAgICAgKHRoaXMuY29uZmlnLnRodW1iUG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMuY29uZmlnLnRodW1iUG9zaXRpb24gPT09ICdib3R0b20nKTtcclxuICB9XHJcblxyXG4gIEBJbnB1dCgpIGdhbGxlcnlJZDogc3RyaW5nO1xyXG5cclxuICBASW5wdXQoKSBhZGFwdGVyOiBTbGlkZXJBZGFwdGVyO1xyXG5cclxuICBASW5wdXQoKSBjb25maWc6IEdhbGxlcnlDb25maWc7XHJcblxyXG4gIEBPdXRwdXQoKSBpc1Jlc2l6aW5nQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcclxuICAgICAgICAgICAgICBwcml2YXRlIF96b25lOiBOZ1pvbmUsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfZ2FsbGVyeTogR2FsbGVyeSxcclxuICAgICAgICAgICAgICBwcml2YXRlIF9pbWdNYW5hZ2VyOiBJbWdNYW5hZ2VyKSB7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgIGNvbnN0IGdhbGxlcnlSZWY6IEdhbGxlcnlSZWYgPSB0aGlzLl9nYWxsZXJ5LnJlZih0aGlzLmdhbGxlcnlJZCk7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgaGVpZ2h0IGhhcyB0cmFuc2l0aW9uIGZvciB0aGUgYXV0by1oZWlnaHQgZmVhdHVyZVxyXG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uOiBzdHJpbmcgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX3ZpZXdwb3J0KS5nZXRQcm9wZXJ0eVZhbHVlKCd0cmFuc2l0aW9uLWR1cmF0aW9uJyk7XHJcbiAgICBpZiAocGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pID09PSAwKSB7XHJcbiAgICAgIHRoaXMuX2FmdGVySGVpZ2h0Q2hhbmdlZCQgPSBvZihudWxsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2FmdGVySGVpZ2h0Q2hhbmdlZCQgPSBmcm9tRXZlbnQodGhpcy5fdmlld3BvcnQsICd0cmFuc2l0aW9uZW5kJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcblxyXG4gICAgICAvLyBEZXRlY3QgaWYgdGhlIHNpemUgb2YgdGhlIHNsaWRlciBoYXMgY2hhbmdlZCBkZXRlY3RpbmcgY3VycmVudCBpbmRleCBvbiBzY3JvbGxcclxuICAgICAgdGhpcy5fcmVzaXplU3Vic2NyaXB0aW9uID0gcmVzaXplT2JzZXJ2YWJsZSh0aGlzLl92aWV3cG9ydCwgKG9ic2VydmVyOiBSZXNpemVPYnNlcnZlcikgPT4gdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBvYnNlcnZlcikucGlwZShcclxuICAgICAgICAvLyBDaGVjayBpZiByZXNpemUgc2hvdWxkIHNraXAgZHVlIHRvIHJlLW9ic2VydmluZyB0aGUgc2xpZGVyXHJcbiAgICAgICAgZmlsdGVyKCgpID0+ICF0aGlzLl9zaG91bGRTa2lwIHx8ICEodGhpcy5fc2hvdWxkU2tpcCA9IGZhbHNlKSksXHJcbiAgICAgICAgLy8gSW1tZWRpYXRlbHkgc2V0IHZpc2liaWxpdHkgdG8gaGlkZGVuIHRvIGF2b2lkIGNoYW5naW5nIHRoZSBhY3RpdmUgaXRlbSBjYXVzZWQgYnkgYXBwZWFyYW5jZSBvZiBvdGhlciBpdGVtcyB3aGVuIHNpemUgaXMgZXhwYW5kZWRcclxuICAgICAgICB0YXAoKCkgPT4gdGhpcy5zZXRSZXNpemluZ1N0YXRlKCkpLFxyXG4gICAgICAgIGRlYm91bmNlVGltZSh0aGlzLmNvbmZpZy5yZXNpemVEZWJvdW5jZVRpbWUsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKSxcclxuICAgICAgICB0YXAoYXN5bmMgKGVudHJ5OiBSZXNpemVPYnNlcnZlckVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgQ1NTIHZhcmlhYmxlcyB3aXRoIHRoZSBwcm9wZXIgdmFsdWVzXHJcbiAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlclNpemUoKTtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5faXNBdXRvSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltZzogSFRNTEltYWdlRWxlbWVudCA9IGF3YWl0IGZpcnN0VmFsdWVGcm9tKHRoaXMuX2ltZ01hbmFnZXIuZ2V0QWN0aXZlSXRlbShnYWxsZXJ5UmVmLnN0YXRlKSk7XHJcbiAgICAgICAgICAgIC8vIElmIGltZyBoZWlnaHQgaXMgaWRlbnRpY2FsIHRvIHRoZSB2aWV3cG9ydCBoZWlnaHQgdGhlbiBza2lwXHJcbiAgICAgICAgICAgIGlmIChpbWcuaGVpZ2h0ID09PSB0aGlzLl92aWV3cG9ydC5jbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICB0aGlzLnJlc2V0UmVzaXppbmdTdGF0ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIC8vIFVub2JzZXJ2ZSB0aGUgc2xpZGVyIHdoaWxlIHRoZSBoZWlnaHQgaXMgYmVpbmcgY2hhbmdlZFxyXG4gICAgICAgICAgICAgIHRoaXMuc2V0UmVzaXppbmdTdGF0ZSh7IHVub2JzZXJ2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAvLyBDaGFuZ2UgdGhlIGhlaWdodFxyXG4gICAgICAgICAgICAgIHRoaXMuX2dhbGxlcnlDb3JlLnN0eWxlLnNldFByb3BlcnR5KCctLXNsaWRlci1oZWlnaHQnLCBgJHsgaW1nLmhlaWdodCB9cHhgKTtcclxuICAgICAgICAgICAgICAvLyBXYWl0IHVudGlsIGhlaWdodCB0cmFuc2l0aW9uIGVuZHNcclxuICAgICAgICAgICAgICBhd2FpdCBmaXJzdFZhbHVlRnJvbSh0aGlzLl9hZnRlckhlaWdodENoYW5nZWQkKTtcclxuICAgICAgICAgICAgICB0aGlzLnJlc2V0UmVzaXppbmdTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHRvIHNraXAgZmlyc3QgZW1pdCBhZnRlciByZS1vYnNlcnZpbmcgdGhlIHNsaWRlciBpZiBoZWlnaHQgY29udGVudCByZWN0IGhlaWdodCBhbmQgY2xpZW50IGhlaWdodCBhcmUgaWRlbnRpY2FsXHJcbiAgICAgICAgICAgICAgICBzaG91bGRTa2lwOiBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQgPT09IHRoaXMuX3ZpZXdwb3J0LmNsaWVudEhlaWdodCxcclxuICAgICAgICAgICAgICAgIG9ic2VydmU6IHRydWVcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMucmVzZXRSZXNpemluZ1N0YXRlKHsgc2hvdWxkU2tpcDogdHJ1ZSB9KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgKS5zdWJzY3JpYmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9pc0F1dG9IZWlnaHQgPyB0aGlzLl9zdWJzY3JpYmVBdXRvSGVpZ2h0KCkgOiB0aGlzLl91bnN1YnNjcmliZUF1dG9IZWlnaHQoKTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fcmVzaXplU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xyXG4gICAgdGhpcy5fdW5zdWJzY3JpYmVBdXRvSGVpZ2h0KCk7XHJcbiAgfVxyXG5cclxuICBuZ0FmdGVyVmlld0NoZWNrZWQoKTogdm9pZCB7XHJcbiAgICB0aGlzLnVwZGF0ZVNsaWRlclNpemUoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlU2xpZGVyU2l6ZSgpOiB2b2lkIHtcclxuICAgIC8vIFVwZGF0ZSBzbGlkZXIgd2lkdGggYW5kIGhlaWdodCBDU1MgdmFyaWFibGVzXHJcbiAgICB0aGlzLl9nYWxsZXJ5Q29yZS5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1zbGlkZXItd2lkdGgnLCBgJHsgdGhpcy5fdmlld3BvcnQuY2xpZW50V2lkdGggfXB4YCk7XHJcblxyXG4gICAgLy8gT25seSB1cGRhdGUgaGVpZ2h0IGlmIGF1dG8taGVpZ2h0IGlzIGZhbHNlLCBiZWNhdXNlIHdoZW4gaXQncyB0cnVlLCBhbm90aGVyIGZ1bmN0aW9uIHdpbGwgdGFrZSBjYXJlIG9mIGl0XHJcbiAgICBpZiAoIXRoaXMuY29uZmlnLmF1dG9IZWlnaHQpIHtcclxuICAgICAgdGhpcy5fZ2FsbGVyeUNvcmUuc3R5bGUuc2V0UHJvcGVydHkoJy0tc2xpZGVyLWhlaWdodCcsIGAkeyB0aGlzLl92aWV3cG9ydC5jbGllbnRIZWlnaHQgfXB4YCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy51cGRhdGVDZW50cmFsaXplQ1NTVmFyaWFibGVzKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZUNlbnRyYWxpemVDU1NWYXJpYWJsZXMoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5jb25maWcuaXRlbUF1dG9zaXplKSB7XHJcbiAgICAgIHRoaXMuX2dhbGxlcnlDb3JlLnN0eWxlLnNldFByb3BlcnR5KCctLXNsaWRlci1jZW50cmFsaXplLXN0YXJ0LXNpemUnLCBgJHsgdGhpcy5hZGFwdGVyLmdldENlbnRyYWxpemVyU3RhcnRTaXplKCkgfXB4YCk7XHJcbiAgICAgIHRoaXMuX2dhbGxlcnlDb3JlLnN0eWxlLnNldFByb3BlcnR5KCctLXNsaWRlci1jZW50cmFsaXplLWVuZC1zaXplJywgYCR7IHRoaXMuYWRhcHRlci5nZXRDZW50cmFsaXplckVuZFNpemUoKSB9cHhgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3N1YnNjcmliZUF1dG9IZWlnaHQoKTogdm9pZCB7XHJcbiAgICB0aGlzLl91bnN1YnNjcmliZUF1dG9IZWlnaHQoKTtcclxuXHJcbiAgICB0aGlzLl9zaG91bGRTa2lwID0gZmFsc2U7XHJcbiAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuXHJcbiAgICAgIGNvbnN0IGdhbGxlcnlSZWY6IEdhbGxlcnlSZWYgPSB0aGlzLl9nYWxsZXJ5LnJlZih0aGlzLmdhbGxlcnlJZCk7XHJcblxyXG4gICAgICAvLyBUT0RPOiBXaHkgaXMgZ2FsbGVyeVJlZi5zdGF0ZSBlbWl0cyB3aGVuIHNjcmVlbiBzaXplIGNoYW5nZXM/XHJcbiAgICAgIGNvbnN0IHN0YXRlOiBPYnNlcnZhYmxlPEdhbGxlcnlTdGF0ZT4gPSBnYWxsZXJ5UmVmLnN0YXRlLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKGE6IEdhbGxlcnlTdGF0ZSwgYjogR2FsbGVyeVN0YXRlKSA9PiBhLmN1cnJJbmRleCA9PT0gYi5jdXJySW5kZXgpKVxyXG4gICAgICB0aGlzLl9hdXRvSGVpZ2h0U3Vic2NyaXB0aW9uID0gdGhpcy5faW1nTWFuYWdlci5nZXRBY3RpdmVJdGVtKHN0YXRlKS5waXBlKFxyXG4gICAgICAgIHN3aXRjaE1hcCgoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnNldFJlc2l6aW5nU3RhdGUoeyB1bm9ic2VydmU6IHRydWUgfSk7XHJcbiAgICAgICAgICB0aGlzLl9nYWxsZXJ5Q29yZS5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1zbGlkZXItaGVpZ2h0JywgYCR7IGltZy5jbGllbnRIZWlnaHQgfXB4YCk7XHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5ldyBpdGVtIGhlaWdodCBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBoZWlnaHQsIHRoZXJlIHdpbGwgYmUgbm8gdHJhbnNpdGlvbixcclxuICAgICAgICAgIC8vIFNvIHJlc2V0IHJlc2l6aW5nIHN0YXRlXHJcbiAgICAgICAgICBpZiAoaW1nLmhlaWdodCA9PT0gdGhpcy5fdmlld3BvcnQuY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRSZXNpemluZ1N0YXRlKHsgc2hvdWxkU2tpcDogdHJ1ZSwgb2JzZXJ2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FmdGVySGVpZ2h0Q2hhbmdlZCQucGlwZShcclxuICAgICAgICAgICAgdGFwKCgpID0+IHRoaXMucmVzZXRSZXNpemluZ1N0YXRlKHsgc2hvdWxkU2tpcDogdHJ1ZSwgb2JzZXJ2ZTogdHJ1ZSB9KSksXHJcbiAgICAgICAgICAgIHRha2UoMSlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKS5zdWJzY3JpYmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfdW5zdWJzY3JpYmVBdXRvSGVpZ2h0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fYXV0b0hlaWdodFN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2V0UmVzaXppbmdTdGF0ZSh7IHVub2JzZXJ2ZSB9OiB7IHVub2JzZXJ2ZT86IGJvb2xlYW4gfSA9IHt9KTogdm9pZCB7XHJcbiAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgIHRoaXMuaXNSZXNpemluZ0NoYW5nZS5lbWl0KHRydWUpO1xyXG4gICAgfSlcclxuICAgIHRoaXMuX3ZpZXdwb3J0LmNsYXNzTGlzdC5hZGQoJ2ctcmVzaXppbmcnKTtcclxuICAgIGlmICh1bm9ic2VydmUpIHtcclxuICAgICAgLy8gVW5vYnNlcnZlIHRoZSBzbGlkZXIgd2hpbGUgdGhlIGhlaWdodCBpcyBiZWluZyBjaGFuZ2VkXHJcbiAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLl92aWV3cG9ydCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlc2V0UmVzaXppbmdTdGF0ZSh7IHNob3VsZFNraXAsIG9ic2VydmUgfTogeyBzaG91bGRTa2lwPzogYm9vbGVhbiwgb2JzZXJ2ZT86IGJvb2xlYW4gfSA9IHt9KTogdm9pZCB7XHJcbiAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgIHRoaXMuaXNSZXNpemluZ0NoYW5nZS5lbWl0KGZhbHNlKTtcclxuICAgIH0pXHJcbiAgICB0aGlzLl92aWV3cG9ydC5jbGFzc0xpc3QucmVtb3ZlKCdnLXJlc2l6aW5nJyk7XHJcbiAgICB0aGlzLl9zaG91bGRTa2lwID0gc2hvdWxkU2tpcDtcclxuICAgIGlmIChvYnNlcnZlKSB7XHJcbiAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5fdmlld3BvcnQpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=